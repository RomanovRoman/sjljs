<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: input/InputFilter.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: input/InputFilter.js</h1>

    


    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Created by Ely on 7/24/2014.
 */

'use strict';

(function (context) {

    context.sjl.InputFilter = context.sjl.Optionable.extend(

        function InputFilter(options) {

            // Set defaults as options on this class
            context.sjl.Optionable.call(this, {
                data: [],
                inputs: {},
                invalidInputs: [],
                validInputs: [],
                validationGroup: null,
                messages: {}
            });

            sjl.extend(true, this.options, options);

        }, {

            // @todo beef up add, get, and has methods (do param type checking before using param)
            add: function (value) {
                if (value instanceof context.sjl.Input) {
                    this.getInputs()[value.getAlias()] = value;
                }

                return this;
            },

            get: function (value) {
                return this.getInputs()[value];
            },

            has: function (value) {
                return this.getInputs().hasOwnProperty(value);
            },

            isValid: function () {
                var self = this,
                    inputs = self.getInputs(),
                    data = self.getData();

                self.clearInvalidInputs()
                    .clearValidInputs()
                    .clearMessages();

                // Populate inputs with data
                self.setDataOnInputs();


                // If no data bail and throw an error
                if (context.sjl.empty(data)) {
                    throw new Error('InputFilter->isValid could\'nt ' +
                        'find any data for validation.');
                }

                return self.validateInputs(inputs, data);
            },

            validateInput: function (input, dataMap) {
                var name = input.getAlias(),
                    dataExists = context.sjl.isset(dataMap[name]),
                    data = dataExists ? dataMap[name] : null,
                    required = input.getRequired(),
                    allowEmpty = input.getAllowEmpty(),
                    continueIfEmpty = input.getContinueIfEmpty(),
                    retVal = true;

                // If data doesn't exists and input is not required
                if (!dataExists &amp;&amp; !required) {
                    retVal = true;
                }

                // If data doesn't exist, input is required, and input allows empty value,
                // then input is valid only if continueIfEmpty is false;
                else if (!dataExists &amp;&amp; required &amp;&amp; allowEmpty &amp;&amp; !continueIfEmpty) {
                    retVal = true;
                }

                // If data exists, is empty, and not required
                else if (dataExists &amp;&amp; context.sjl.empty(data) &amp;&amp; !required) {
                    retVal = true;
                }

                // If data exists, is empty, is required, and allows empty,
                // then input is valid if continue if empty is false
                else if (dataExists &amp;&amp; context.sjl.empty(data) &amp;&amp; required
                    &amp;&amp; allowEmpty &amp;&amp; !continueIfEmpty) {
                    retVal = true;
                }

                else if (!input.isValid()) {
                    retVal = false;
                }

                return retVal;
            },

            validateInputs: function (inputs, data) {
                var self = this,
                    validInputs = {},
                    invalidInputs = {},
                    retVal = true,

                    // Input vars
                    input, name;

                // Get inputs
                inputs = inputs || self.getInputs();

                // Get data
                data = data || self.getRawValues();

                // Validate inputs
                for (input in inputs) {
                    if (!inputs.hasOwnProperty(input)) {
                        continue;
                    }
                    name = input;
                    input = inputs[input];

                    // @todo Check that input has the required interface(?)
                    if (self.validateInput(input, data)) {
                        validInputs[name] = input;
                    }
                    else {
                        invalidInputs[name] = input;
                    }
                }

                // If no invalid inputs then validation passed
                if (context.sjl.empty(invalidInputs)) {
                    retVal = true;
                }
                // else validation failed
                else {
                    retVal = false;
                }

                // Set valid inputs
                self.setOption('validInputs', validInputs);

                // Set invalid inputs
                self.setOption('invalidInputs', invalidInputs);

                return retVal;
            },

            setInputs: function (inputs) {
                var self = this,
                    input, name,
                    validators;

                // Set default inputs value if inputs is not of type 'Object'
                if (!context.sjl.classOfIs(inputs, 'Object')) {
                    self.options.inputs = inputs = {};
                }

                // Populate inputs
                for (input in inputs) {
                    if (!inputs.hasOwnProperty(input)) {
                        continue;
                    }

                    name = input;

                    validators = self._getValidatorsFromInputHash(inputs[input]);
                    inputs[input].validators = null;
                    delete inputs[input].validators;

                    // Set name if it is not set
                    if (!context.sjl.isset(inputs[input].alias)) {
                      inputs[input].alias = name;
                    }

                    // Create input
                    input = new context.sjl.Input(inputs[input]);

                    // Set input's validators
                    input.getValidatorChain().addValidators(validators);

                    // Save input
                    self.options.inputs[input.getAlias()] = input;
                }

                return self;
            },

            getInputs: function () {
                var self = this;
                if (!context.sjl.classOfIs(self.options.inputs, 'Object')) {
                    self.options.inputs = {};
                }
                return self.options.inputs;
            },

            remove: function (value) {
                var self = this,
                    inputs = self.options.inputs;
                if (inputs.hasOwnProperty(value)) {
                    inputs[value] = null;
                    delete self.options.inputs[value];
                }
                return self;
            },

            setData: function (data) {
                var self = this;
                self.options.data = data;
                return self;
            },

            getData: function () {
                return this.options.data;
            },

            setValidationGroup: function () {
            },

            getInvalidInputs: function () {
                if (!context.sjl.classOfIs(this.options.invalidInputs, 'Object')) {
                    this.options.invalidInputs = {};
                }
                return this.options.invalidInputs;
            },

            getValidInputs: function () {
                if (!context.sjl.classOfIs(this.options.validInputs, 'Object')) {
                    this.options.validInputs = {};
                }
                return this.options.validInputs;
            },

            getRawValues: function () {
                var self = this,
                    rawValues = {},
                    input,
                    invalidInputs = self.getInvalidInputs();

                for (input in invalidInputs) {
                    if (!invalidInputs.hasOwnProperty(input)) {
                        continue;
                    }
                    input = invalidInputs[input];
                    rawValues[input.getAlias()] = input.getRawValue();
                }
                return rawValues;
            },

            getValues: function () {
                var self = this,
                    values = {},
                    input,
                    invalidInputs = self.getInvalidInputs();

                for (input in invalidInputs) {
                    if (!invalidInputs.hasOwnProperty(input)) {
                        continue;
                    }
                    input = invalidInputs[input];
                    values[input.getAlias()] = input.getValue();
                }
                return values;
            },

            getMessages: function () {
                var self = this,
                    messages = self.options.messages,
                    input, key,
                    invalidInputs = self.getInvalidInputs(),
                    messageItem;

                for (key in invalidInputs) {
                    if (!invalidInputs.hasOwnProperty(key)) {
                        continue;
                    }
                    input = invalidInputs[key];
                    if (sjl.empty())
                    messageItem = messages[input.getAlias()];
                    if (sjl.classOfIs(messageItem, 'Array')) {
                        messages[input.getAlias()] = messageItem.concat(input.getMessages());
                    }
                    else {
                        messages[input.getAlias()] = input.getMessages();
                    }
                }
                return messages;
            },

            mergeMessages: function (messages) {
                if (!messages) {
                    throw new Error('`InputFilter.mergeMessages` requires a "messages" hash parameter.');
                }
                var currentMessages = this.options.messages,
                    key;
                for (key in messages) {
                    if (messages.hasOwnProperty(key)) {
                        currentMessages[key] = messages[key].concat(currentMessages.hasOwnProperty(key) ? currentMessages[key] : []);
                    }
                }
                return this;
            },

            clearMessages: function () {
                this.options.messages = {};
            },

            setDataOnInputs: function (data) {
                var self = this,
                    inputs = self.getInputs(),
                    key;

                data = data || self.getData();

                for (key in data) {
                    if (!data.hasOwnProperty(key)
                         || !context.sjl.isset(inputs[key])
                         || !context.sjl.isset(data[key])) {
                        continue;
                    }
                    inputs[key].setValue(data[key]);
                }
            },

            clearValidInputs: function () {
                this.setOption('validInputs', {});
                return this;
            },

            clearInvalidInputs: function () {
                this.setOption('invalidInputs', {});
                return this;
            },

            _getValidatorsFromInputHash: function (inputHash) {
                return context.sjl.isset(inputHash.validators) ? inputHash.validators : null;
            }

        }, {

            factory: function (inputSpec) {
                if (!context.sjl.classOfIs(inputSpec, 'Object')
                    || !context.sjl.isset(inputSpec.inputs)) {
                    throw new Error('InputFilter class expects param 1 to be of type "Object".');
                }
                var inputFilter = new context.sjl.InputFilter();
                inputFilter.setInputs(inputSpec.inputs);
                return inputFilter;
            },

            VALIDATE_ALL: 0

        });

})(typeof window === 'undefined' ? global : window);
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-sjl.html">sjl</a></li></ul><h3>Classes</h3><ul><li><a href="sjl.Attributable.html">Attributable</a></li><li><a href="sjl.html#Extendable">Extendable</a></li><li><a href="sjl.Iterator.html">Iterator</a></li><li><a href="sjl.ObjectIterator.html">ObjectIterator</a></li><li><a href="sjl.Optionable.html">Optionable</a></li><li><a href="sjl.SjlSet.html">SjlSet</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-alpha5</a> on Wed Aug 19 2015 03:46:43 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
